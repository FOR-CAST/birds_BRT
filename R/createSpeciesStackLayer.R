createSpeciesStackLayer <- function(modelList,
                                    pixelsWithDataAtInitialization = NULL,
                                    simulatedBiomassMap,
                                    urlStaticLayer,
                                    cohortData, # Should also have age
                                    sppEquiv,
                                    sppEquivCol,
                                    staticLayers,
                                    pixelGroupMap,
                                    pathData,
                                    forestOnly,
                                    uplandsRaster,
                                    rasterToMatch,
                                    useOnlyUplandsForPrediction,
                                    useStaticPredictionsForNonForest,
                                    makeAssertions = TRUE,
                                    version,
                                    allVariables,
                                    urlStaticLayers,
                                    studyArea,
                                    Province) {
  message("Biomass data was simulated, using it for prediction.")

  knownClimateCovariates <- c(
    "AHM", "bFFP", "CMD", "DD_0", "DD_18",
    "DD18", "DD5", "eFFP", "EMT", "EXT", "FFP",
    "MAP", "MAT", "MCMT", "MSP", "MWMT", "NFFD",
    "PAS", "PPT_sm", "PPT_wt", "SHM", "Tave_sm",
    "Tave_wt", "TD"
  )

  message(crayon::yellow(paste0(
    "The following layers are known climate covariates and will be used to check for ",
    "missing layers. If the simulation fails, please check that all needed climate ",
    "covariates are being generated by this module: \n",
    paste(knownClimateCovariates, collapse = "; ")
  )))

  # Create layer names based on the model
  if (version == "reducedBAM") {
    predictors <- allVariables
  } else {
    predictors <- modelList[[1]]$gbm.call$predictor.names
  }
  speciesNames <- unique(na.omit(sppEquiv[, ..sppEquivCol])[[1]])
  speciesNames <- speciesNames[speciesNames != ""] # Remove empty names i.e., ""
  # Add any potential species we don't have in LandR equiv. Table, but have in the
  # models with a warning/message
  # 1. First, get all species and landsc predictors
  spFromPredictors <- predictors[grepl(pattern = "Landsc|Species", x = predictors)]
  # 2. Remove what I know doens't belong
  toRem <- c("Age", "Broadleaf", "Needleleaf")
  spFromPredictors <- spFromPredictors[!grepl(
    pattern = paste(toRem, collapse = "|"),
    x = spFromPredictors
  )]
  # 3. Get the species names based on '_'
  spFromPredictors <- unlist(lapply(spFromPredictors, function(ind) {
    paste(strsplit(ind, split = "_")[[1]][2:3], collapse = "_")
  }))
  # 4. Identify if there are any species in the predictors that do not exist in LandR Eqv. table
  missingSp <- setdiff(spFromPredictors, speciesNames)
  # 5. Create the table for missing layers
  if (length(missingSp) != 0) {
    speciesLayerNamesMiss <- rbindlist(lapply(X = missingSp, FUN = function(sp) {
      whichLay <- predictors[grepl(sp, predictors)]
      if (length(whichLay) == 0) {
        whichLay <- NA
      }
      speciesDT <- data.table::data.table(
        modelLayer = whichLay,
        speciesName = sp
      )
      return(speciesDT)
    }))
  }
  speciesLayerNames <- rbindlist(lapply(X = speciesNames, FUN = function(sp) {
    whichLay <- predictors[grepl(sp, predictors)]
    if (length(whichLay) == 0) {
      whichLay <- NA
    }
    speciesDT <- data.table::data.table(
      modelLayer = whichLay,
      speciesName = sp
    )
    return(speciesDT)
  }))

  # 6. If there are any missing species, add
  if (length(missingSp) != 0) {
    speciesLayerNames <- rbind(speciesLayerNames, speciesLayerNamesMiss, use.names = TRUE)
  }
  # Cleanup from NA's
  speciesLayerNames <- na.omit(speciesLayerNames)

  # Separate those that are species than the landscape ones, but only on models
  # older than reducedBAM:
  if (version %in% c(1:8, "6a")) {
    speciesLayerNames <- speciesLayerNames[!grepl(pattern = "Landsc", x = speciesLayerNames$modelLayer), ]
  }

  # Separate those that are species than the group ones:
  speciesLayerNames <- speciesLayerNames[!grepl(pattern = "Groups", x = speciesLayerNames$modelLayer), ]

  # Here is where birds get masked to upland forested sites only. We should not do that IF LandR is predicting well for
  # lower biomass sites
  if (useOnlyUplandsForPrediction) {
    if (!all(unlist(lapply(list(uplandsRaster, forestOnly, rasterToMatch), FUN = is, class2 = "RasterLayer")))) {
      stop("At least one of your layers (sim$uplandsRaster, sim$forestOnly, sim$rasterToMatch) is NULL. Please debug.")
    }
    forestUplandRTM <- uplandsRaster * forestOnly * rasterToMatch
    if (any(!names(table(forestUplandRTM[], useNA = "ifany")) %in% c("0", "1", NA))) {
      forestUplandRTM[forestUplandRTM > 0 | forestUplandRTM < 0] <- 1
    }
    if (any(!names(table(forestUplandRTM[], useNA = "ifany")) %in% c("0", "1", NA))) {
      stop(
        "One or more of your rasters (sim$uplandsRaster, sim$forestOnly, sim$rasterToMatch)",
        " is not binary even after converting. Please debug."
      )
    }

    pixelGroupMap <- Cache(postProcess,
      x = pixelGroupMap,
      rasterToMatch = forestUplandRTM,
      destinationPath = tempdir(),
      filename2 = NULL,
      maskWithRTM = TRUE,
      useCache = FALSE
    )
  }

  # Need to get the LandR equivalent of the species layer. While species layer
  # uses the following species notation 'Abie_Bal', LandR uses 'Abie_bal'
  eqvTB <- sppEquiv[, c("KNN", "LandR")]
  eqvTB <- eqvTB[KNN != "" & LandR != "", ] # TODO: If I ever add data sources other than KNN,
  # 'KNN != "" &' needs to be removed
  speciesLayerNames <- merge(speciesLayerNames, eqvTB,
    all.x = TRUE,
    by.x = "speciesName", by.y = "KNN"
  ) # Previous eqvTBred
  # At this point, if we have species in the table that we don't have in LandR,
  # we need to add them
  speciesLayerNamesNA <- speciesLayerNames[is.na(LandR), ]
  # leave only the real species
  toRem <- c("Age", "Broadleaf", "Needleleaf")
  speciesLayerNamesNA <- speciesLayerNamesNA[!speciesName %in% speciesName[grepl(x = speciesName, pattern = paste(toRem, collapse = "|"))], ]
  speciesLayerNamesToFill <- speciesLayerNamesNA[, speciesName]
  speciesLayerNamesToFill <- unlist(lapply(speciesLayerNamesToFill, function(SP) {
    gen <- strsplit(x = SP, split = "_")[[1]][1]
    sP <- tolower(strsplit(x = SP, split = "_")[[1]][2])
    if (sP == "spp") sP <- "sp"
    return(paste(gen, sP, sep = "_"))
  }))
  speciesLayerNames[speciesName %in% speciesLayerNamesNA[, speciesName], LandR := speciesLayerNamesToFill]

  # Iterate through species and for each species, plot the B in the `pixelGroupMap`
  if (version %in% c(1:8, "6a")) {
    names(speciesNames) <- speciesLayerNames$modelLayer[match(speciesLayerNames$speciesName, speciesNames)]
  } else {
    speciesNames <- unique(speciesLayerNames$LandR)
  }
  zeroedMap <- raster(pixelGroupMap)
  if (!is.null(pixelsWithDataAtInitialization)) {
    # here I need to "fill back up" or 'extend' my cohort data to the pixels that had biomass and don't have anymore
    # pixelsWithDataAtInitialization
    zeroPixGroup <- data.table(pixelID = pixelsWithDataAtInitialization)
    zeroPixGroup$pixThatHadBiomass <- pixelGroupMap[pixelsWithDataAtInitialization]
    zeroPixGroup <- zeroPixGroup[is.na(pixThatHadBiomass), ]
    pixelGroupMap[zeroPixGroup$pixelID] <- 0 # Do we have any pixelGroup as 0? No
  }
  pixelGroupMapRed <- data.table(pixelGroup = unique(raster::getValues(pixelGroupMap)))
  pixelGroupMapRed <- na.omit(pixelGroupMapRed)
  if (!is.null(pixelsWithDataAtInitialization)) {
    # here I need to "fill back up" or 'extend' my cohort data to the pixels that had biomass and don't have anymore
    # pixelsWithDataAtInitialization
    cohortDataZeroed <- data.table(matrix(0,
      nrow = length(levels(cohortData$speciesCode)),
      ncol = NCOL(cohortData)
    ))
    names(cohortDataZeroed) <- names(cohortData)
    cohortDataZeroed$speciesCode <- levels(cohortData$speciesCode)
    cohortData <- rbind(cohortData, cohortDataZeroed)
  }
  cohortData <- cohortData[pixelGroupMapRed, on = "pixelGroup"]
  if (makeAssertions) {
    if (NROW(cohortData) != NROW(na.omit(cohortData))) {
      stop("cohortData has NA's. Please debug!")
    }
  }

  ###################### MAKE THE SPECIES LAYERS  ######################

  whichSp <- unique(speciesNames[!is.na(speciesNames)])

  # Need to separate any Spp or sp because they are unidentified to species
  # level, likely hybrids. The way we will deal with this here is:
  # Use X_Spp as a mask, find out which X is dominating (i.e., pmax),
  # and use that value in the pixels to create Spp
  # TODO: We will have to discuss how to approach this in LandR. We might need
  # to start simulating Spp as well --> but need to identify which traits
  # to use first
  genusOnly <- unique(whichSp[grepl(pattern = "_sp|_Spp", x = whichSp)])
  whichSp <- whichSp[!whichSp %in% genusOnly]

  # Species level raster
  speciesRasters <- lapply(X = whichSp, FUN = function(sp) {
    # TODO: Make this into a function and use it below too
    subsCohort <- cohortData[speciesCode == sp, ]
    zeroedMap[] <- getValues(pixelGroupMap)
    vals <- getValues(x = zeroedMap)
    vals[!is.na(vals)] <- 0
    zeroedMap <- setValues(x = zeroedMap, values = vals)
    if (NROW(subsCohort) != 0) {
      valsCoho <- data.table(
        pixelID = 1:ncell(pixelGroupMap),
        pixelGroup = getValues(x = pixelGroupMap)
      )
      joinOn <- c("speciesCode", "pixelGroup")
      newCohoVals <- valsCoho[subsCohort[, list(sumBiomass = sum(B)), by = joinOn],
        on = "pixelGroup"
      ]
      zeroedMap[newCohoVals$pixelID] <- newCohoVals$sumBiomass
    }
    if (version %in% c(1:8, "6a")) {
      names(zeroedMap) <- speciesLayerNames[speciesName == sp, modelLayer]
    } else {
      nm <- speciesLayerNames[LandR == sp, modelLayer]
      # Now I need to replace any potential "non-Species" layers
      # (i.e., Landsc750) by 'Species'
      if (any(grepl(x = nm, pattern = "Landsc750"))) {
        names(zeroedMap) <- unique(gsub(pattern = "Landsc750", replacement = "Species", x = nm))
      } else {
        names(zeroedMap) <- nm
      }
    }
    return(zeroedMap)
  })
  names(speciesRasters) <- names(stack(speciesRasters))

  # Genus level raster
  genusRasters <- lapply(X = genusOnly, FUN = function(sp) {
    # TODO: Make this into a function and use it below too
    # 1. Load original raster for the given species
    spLayerName <- speciesLayerNames[LandR == sp, modelLayer]
    if (length(spLayerName) > 1) {
      # If I have both Landsc and Species for a given one, I need to get only the
      # Species
      spLayerName <- spLayerName[grepl(pattern = "Species", x = spLayerName)]
    }
    # Exclude the columns that do not belong to the species genus
    spLandRName <- speciesLayerNames[modelLayer == spLayerName, LandR]
    genus <- strsplit(x = spLandRName, split = "_")[[1]][1]

    # We have several cohorts per pixel. Need to sum the biomass
    toKeep <- as.character(unique(cohortData[["speciesCode"]])[
      grepl(pattern = genus, x = unique(cohortData[["speciesCode"]]))
    ])

    if (length(toKeep) != 0) { # If we don't have the species in our simulations, toKeep will have length == 0
      cohortSummed <- rbindlist(lapply(toKeep, function(sps) {
        subsCohort <- cohortData[speciesCode == sps, ]
        valsCoho <- data.table(
          pixelID = 1:ncell(pixelGroupMap),
          pixelGroup = getValues(x = pixelGroupMap)
        )
        joinOn <- c("speciesCode", "pixelGroup")
        cohortDataS <- valsCoho[subsCohort[, list(sumBiomass = sum(B)), by = joinOn],
          on = "pixelGroup"
        ]
        return(cohortDataS)
      }))

      # 2. Use it as a "mask": Extract which pixels have information on biomass
      # i.e., not NA and > 0
      originalSpp <- Cache(loadStaticLayers,
        fileURL = urlStaticLayers, # Add Cache when fun is ready
        pathData = pathData,
        studyArea = studyArea,
        rasterToMatch = rasterToMatch,
        Province = Province,
        version = version,
        allVariables = spLayerName,
        staticLayersNames = spLayerName
      )

      originalSppPix <- data.table(
        pixelID = 1:ncell(originalSpp[[1]]),
        vals = getValues(originalSpp[[1]])
      )
      originalSppPix[originalSppPix == 0] <- NA
      originalSppPix <- na.omit(originalSppPix)
      # 3. Find out which species is dominating in these pixels (i.e., pmax) using
      # cohortData
      # Merge both tables to get the pixel ID and merge with cohort data
      cohortWide <- dcast(
        data = cohortSummed, formula = pixelID ~ speciesCode,
        value.var = "sumBiomass"
      )
      sppPixTbCohort <- merge(originalSppPix, cohortWide,
        by = "pixelID", all.x = TRUE
      )
      # 4. Replace that value in the pixels of the mask to create Spp
      for (j in seq_len(ncol(sppPixTbCohort))) {
        set(sppPixTbCohort, which(is.na(sppPixTbCohort[[j]])), j, 0)
      }
      sppPixTbCohort[, valReplace := do.call(what = pmax, .SD), .SDcols = toKeep]
      sppPixTbCohortReady <- sppPixTbCohort[, c("pixelID", "valReplace")]
      sppPixTbCohortReady <- merge(data.table(pixelID = 1:ncell(zeroedMap)),
        sppPixTbCohortReady,
        by = "pixelID",
        all.x = TRUE
      )
      setkey(sppPixTbCohortReady, "pixelID")
      zeroedMap <- setValues(
        x = zeroedMap,
        values = sppPixTbCohortReady[["valReplace"]]
      )
    } else {
      zeroedMap <- pixelGroupMap
      zeroedMap[!is.na(zeroedMap)] <- 0
    }
    # Add the zeroes back, but respecting the places with no data in the beginning
    zeroedMap[!is.na(pixelGroupMap) & is.na(zeroedMap)] <- 0
    # Now naming
    if (version %in% c(1:8, "6a")) {
      names(zeroedMap) <- speciesLayerNames[speciesName == sp, modelLayer]
    } else {
      nm <- speciesLayerNames[LandR == sp, modelLayer]
      # Now I need to replace any potential "non-Species" layers
      # (i.e., Landsc750) by 'Species'
      if (any(grepl(x = nm, pattern = "Landsc750"))) {
        names(zeroedMap) <- unique(gsub(pattern = "Landsc750", replacement = "Species", x = nm))
      } else {
        names(zeroedMap) <- nm
      }
    }
    return(zeroedMap)
  })
  names(genusRasters) <- names(stack(genusRasters))
  # Now I need to put both species and genus layers together
  speciesRasters <- c(speciesRasters, genusRasters)

  # Our species layer have been created using g/m2. Original layers
  # from bird models were in t/ha * 100. We need to convert ours
  # to match what models need:
  # A = g/m2 to B = t/ha
  # B = A/100
  # To get these to t/ha * 100, we multiply then by 100
  # This means we don't need to apply any changes.
  # If you notice the extreme values from the predictions, which
  # seem to be an order magnitude higher than the original layers,
  # it is really just extreme values. Most values are well in the
  # ballpark.

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # browser() # TO CHECK LAYERS
  # layersBAM <- raster::stack(file.path("~/GitHub/WBI_forecasts/modules/birdsNWT/data", paste0("bcr60all_1km.grd")))
  # spInterest <- names(speciesRasters)
  # maxValCalc <- maxValue(stack(speciesRasters[spInterest]))
  # maxValOrig <- maxValue(stack(layersBAM[[spInterest]]))

  # A = g/m2 to B = t/ha
  # B = A/100

  # A = kg/ha to B = t/ha
  # B = A/1000

  # A = g/m2 to B = kg/ha
  # B = A/10

  # Our values are really in g/m2
  # Our values in t/ha x 100
  # round(maxValCalc/100, 0)*100
  #
  # # Original value is t/ha x 100
  # round(maxValOrig, 0)

  # From Original knn layers
  # Browse[1]> totalBiomassAboveGround <- raster::raster("~/GitHub/WBI_forecasts/inputs/NFI_MODIS250m_2011_kNN_Structure_Biomass_TotalLiveAboveGround_v1.tif")
  # Browse[1]> Abie_Bal <- raster::raster("~/GitHub/WBI_forecasts/inputs/NFI_MODIS250m_2011_kNN_Species_Abie_Bal_v1_cache_dataPrep_AB2011.tif")
  # Browse[1]> Abie_Las <- raster::raster("~/GitHub/WBI_forecasts/inputs/NFI_MODIS250m_2011_kNN_Species_Abie_Las_v1_cache_dataPrep_AB2011.tif")
  # Browse[1]> totalBiomassAB <- postProcess(x = totalBiomassAboveGround, studyArea = studyArea)

  # Browse[1]> maxValue(totalBiomassAB*(Abie_Las/100))
  # [1] 115.8765
  # Browse[1]> maxValue(totalBiomassAB*(Abie_Bal/100))
  # [1] 57.95734
  # According to the paper, Knn unit is t/ha

  # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  ###################### MAKE THE BIOMASS LAYER  ######################
  # Add simulated total biomass layer, if present
  biomassLayerName <- predictors[grepl(x = predictors, pattern = "Biomass")]
  biomass <- simulatedBiomassMap
  if (length(biomassLayerName) == 0) {
    biomass <- NULL
  } else {
    names(biomass) <- biomassLayerName
  }

  ###################### MAKE THE AGE LAYER  ######################

  ageLayerName <- predictors[grepl(x = predictors, pattern = "Structure_Stand_Age")]
  ageMap <- raster(pixelGroupMap)
  valsAge <- data.table(pixelID = 1:ncell(ageMap), pixelGroup = getValues(x = pixelGroupMap))
  newAgeVals <- valsAge[cohortData[, list(age = max(age)), by = "pixelGroup"], on = "pixelGroup"]
  ageMap[newAgeVals$pixelID] <- newAgeVals$age
  names(ageMap) <- ageLayerName
  # Select only the species that we actually have interest
  speciesLays <- speciesLayerNames[
    grepl(
      pattern = "Species",
      speciesLayerNames[["modelLayer"]]
    ),
    modelLayer
  ]
  speciesStack <- raster::stack(speciesRasters[names(speciesRasters) %in% speciesLays]) |>
    raster::stack(biomass) |>
    raster::stack(ageMap)

  ############## FIX IF USE PREDICTIONS FOR UPLAND ONLY / NON-FOREST  ########

  if (useStaticPredictionsForNonForest) {
    if (useOnlyUplandsForPrediction) {
      # NOTE: This is the right place for the replacement because we need to calculate the
      # landscape layers. In this case, we need already the species layers with the correct +
      # original values.
      message(paste0(
        "Both useStaticPredictionsForNonForest and useOnlyUplandsForPrediction are TRUE.",
        "\nBiomass maps from simulation will be masked for only uplands and \n",
        "all NA pixels in the map after that will be forecasted using the original biomass \n",
        "layers used to fit the model (kNN, Beaudoin et al., 2017)."
      ))
    }
    if (version %in% c(1:8, "6a")) {
      originalSpeciesLayers <- Cache(prepInputStack,
        url = urlStaticLayer,
        alsoExtract = "similar",
        destinationPath = pathData,
        studyArea = studyArea,
        rasterToMatch = rasterToMatch
      )
    } else {
      laysNeeded <- c(
        speciesLayerNames[["modelLayer"]][grepl(
          x = speciesLayerNames[["modelLayer"]],
          pattern = "Species"
        )],
        ageLayerName
      )
      originalSpeciesLayers <- Cache(loadStaticLayers,
        fileURL = urlStaticLayers, # Add Cache when fun is ready
        pathData = pathData,
        studyArea = studyArea,
        rasterToMatch = rasterToMatch,
        Province = Province,
        version = version,
        allVariables = laysNeeded,
        staticLayersNames = laysNeeded
      )
    }
    message("Original species (i.e., Species) layers contain:")
    message(paste(names(originalSpeciesLayers), collapse = ", "))

    # Matching the rasters names that I have, to mask the NA's
    nameStack <- names(speciesStack)
    matchedLays <- data.frame(
      toMask = seq(1:length(names(speciesStack))),
      original = match(names(speciesStack), names(originalSpeciesLayers))
    )
    matched <- split(matchedLays, seq(nrow(matchedLays)))
    speciesStack <- raster::stack(lapply(X = matched, FUN = function(matching) {
      if (names(speciesStack[[matching[["toMask"]]]]) != names(originalSpeciesLayers[[matching[["original"]]]])) {
        stop("The original species raster and the succession one don't match. Please debug it.")
      } # data sanity check
      valsOriginal <- raster::getValues(originalSpeciesLayers[[matching[["original"]]]])
      valsToMask <- raster::getValues(speciesStack[[matching[["toMask"]]]])
      valsToMask[is.na(valsToMask)] <- valsOriginal[is.na(valsToMask)]
      speciesStack[[matching[["toMask"]]]] <- raster::setValues(
        x = speciesStack[[matching[["toMask"]]]],
        values = valsToMask
      )
      return(speciesStack[[matching[["toMask"]]]])
    }))
    gc()
    names(speciesStack) <- nameStack
  }

  ###################### MAKE THE GROUPS LAYERS  ######################

  groupLayNames <- allVariables[grepl(pattern = "Groups", x = allVariables)]
  if (length(groupLayNames) != 0) {
    groupsLayers <- raster::stack(lapply(groupLayNames, function(layName) {
      specificGroup <- strsplit(x = layName, split = "_")[[1]][2]
      if (specificGroup == "Needleleaf") specificGroup <- "Conifer"
      if (specificGroup == "Broadleaf") specificGroup <- "Deciduous"
      # 1. Make the total biomass raster for the group
      whichBelongToGroup <- unique(sppEquiv[, c("LandR", "Type")])
      allSp <- whichBelongToGroup[Type == specificGroup, LandR]
      spInCurrentGroup <- allSp[allSp %in% unique(speciesLayerNames[, LandR])]
      message(paste0(
        "Building species group layers for ", layName, " (", specificGroup,
        "). The following species are included: ",
        paste(spInCurrentGroup, collapse = ", ")
      ))
      layerNames <- speciesLayerNames[LandR %in% spInCurrentGroup, modelLayer]
      layerNames <- unique(gsub(
        pattern = "Landsc750", replacement = "Species",
        x = layerNames
      ))
      totalBiomass <- calc(stack(speciesRasters[layerNames]), fun = sum)
      names(totalBiomass) <- layName
      return(totalBiomass)
    }))
  } else {
    groupsLayers <- NULL
  }

  speciesStack <- raster::stack(speciesStack) |>
    raster::stack(groupsLayers)

  ###################### MAKE THE LANDCOVER LAYERS  ######################
  # We decided that landcover layers can't really be derived from our data.
  # We are not yet doing landcover transitions. We will keep these static
  # through time. This is also true for the landscape versions of these.
  # Once we can actually account for landcover transition, then we need
  # to separate the ones that are landcover and the ones that are actually
  # landscape derived from landcover.
  # These are layers:
  # Landcover: LandCover_NonVeg_v1, LandCover_Veg_v1, LandCover_VegNonTreed_v1, LandCover_VegTreed_v1
  # Landcover landscape: LandCover_NonVeg_v1.1, LandCover_Veg_v1.1, LandCover_VegNonTreed_v1.1, LandCover_VegTreed_v1.1

  landcoverLayersNames <- predictors[grepl(x = predictors, pattern = "LandCover")]

  landcoverLayers <- Cache(loadStaticLayers,
    fileURL = urlStaticLayers, # Add Cache when fun is ready
    pathData = pathData,
    studyArea = studyArea,
    rasterToMatch = rasterToMatch,
    Province = Province,
    version = version,
    allVariables = landcoverLayersNames,
    staticLayersNames = landcoverLayersNames
  )

  ###################### MAKE THE LANDSCAPE LAYERS  ######################

  landscapeLayerNames <- predictors[grepl(
    pattern = "Landsc",
    x = predictors
  )]

  fw750 <- focalWeight(x = speciesStack[[1]], d = 750, type = "Gauss")
  # Gaussian filter with sigma=750 (tapers off around 2km)
  # Gaussian filter for biomass and age layers

  spLaysForLandscape <- unlist(lapply(strsplit(
    x = landscapeLayerNames,
    split = "Landsc750_"
  ), `[[`, 2))
  tic("Landscape layers elapsed time: ")

  landscapeLays <- stack(lapply(spLaysForLandscape,
    focalWeight = fw750,
    function(lay, focalWeight) {
      spAvailable <- grepl(pattern = lay, x = names(speciesRasters))
      whichStkToUse <- "speciesRasters"
      if (!any(spAvailable)) {
        spAvailable <- grepl(pattern = lay, x = names(speciesStack))
        whichStkToUse <- "speciesStack"
      }
      # The landscape layers and the individual species layers may not match
      # If I have the layer for a given sp in the speciesStack, use it
      if (any(spAvailable)) {
        spRas <- get(whichStkToUse)[[names(get(whichStkToUse))[spAvailable]]]
      } else {
        stop(paste(
          lay, "is not available to build Landscape layer.",
          "This should not happen. Somewhere there is a bug..."
        ))
      }
      if (version %in% c(1:8, "6a")) {
        nm <- paste0(
          "Landsc750_",
          paste(strsplit(x = lay, split = "_")[[1]][2:4],
            collapse = "_"
          )
        )
      } else {
        nm <- paste0("Landsc750_", lay)
      }
      if (any(minValue(spRas) != 0, maxValue(spRas) != 0)) {
        # if we actually have data, calculate the focal
        message(paste0("Calculating landscape gaussian filter for ", nm))
        newR <- raster::focal(spRas, w = focalWeight, na.rm = TRUE)
      } else {
        message(paste0(nm, " has no data. Adding a zeroed landscape map"))
        newR <- spRas
      }
      names(newR) <- nm
      return(newR)
    }
  ))
  toc()
  speciesStack <- raster::stack(speciesStack, landscapeLays, landcoverLayers)

  ###################### CHECKING AND ADDING MISSING LAYERS  ######################

  # Make sure that species that were not modeled by LandR still have a raster
  layersAvailable <- c(
    names(staticLayers),
    names(speciesStack),
    knownClimateCovariates
  )

  missingLayersNames <- setdiff(predictors, layersAvailable)

  if (length(missingLayersNames) == 0) {
    message(crayon::green("No layers missing, proceeding to prediction."))
  }
  if (length(missingLayersNames) != 0) {
    message(crayon::yellow(paste(
      "There are missing layers.",
      "Completing prediction stack with zeroed layers for:"
    )))
    message(crayon::yellow(paste(missingLayersNames, collapse = ", ")))
    missingLayers <- lapply(X = missingLayersNames, FUN = function(miss) {
      zeroedMap <- pixelGroupMap
      vals <- getValues(x = zeroedMap)
      vals[!is.na(vals)] <- 0
      zeroedMap <- setValues(x = zeroedMap, values = vals)
      names(zeroedMap) <- miss
      if (miss == "YEAR") {
        # As YEAR can't be 0, we need to specifically change this one
        message("YEAR is in missing layers. Converting to a '2011' layer")
        zeroedMap[!is.na(zeroedMap)] <- 2011
      }
      return(zeroedMap)
    })
  } else {
    missingLayers <- NULL
  }

  if (!is.null(missingLayers)) {
    finalStk <- raster::stack(missingLayers) |>
      raster::stack(speciesStack)
  } else {
    finalStk <- raster::stack(speciesStack)
  }
  gc()
  return(finalStk)
}
